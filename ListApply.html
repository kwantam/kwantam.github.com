<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Riad Wahby" />
  <title>Uncurrying Functions For Mad(wo)men</title>
  <link rel="stylesheet" href="css/hscolour.css" type="text/css" />
  <link rel="stylesheet" href="css/main.css" type="text/css" />
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Brawler|Inconsolata" type="text/css" />
  <link rel="SHORTCUT ICON" href="images/favicon.png">
</head>
<body>
<div id="header">
<h1 class="title">Uncurrying Functions For Mad(wo)men</h1>
<h2 class="author">Riad Wahby</h2>
<h3 class="date">2013 Apr 21</h3>
</div>
<p>What if we wanted to take a function of several arguments and turn it into an equivalent function that takes a single list containing the arguments?</p><p>Before we begin, I am 100% aware that no sane person would ever really do this; let’s just see what kind of stupid tricks we can do with Template Haskell and the type system.</p><p>At first you might be tempted to do this in a straightforward way by folding:</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>add5</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-varid'>c</span> <span class='hs-varid'>d</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-varop'>+</span> <span class='hs-varid'>b</span> <span class='hs-varop'>+</span> <span class='hs-varid'>c</span> <span class='hs-varop'>+</span> <span class='hs-varid'>d</span> <span class='hs-varop'>+</span> <span class='hs-varid'>e</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>listApply</span>    <span class='hs-conid'>[]</span>  <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fn</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>listApply</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-conop'>:</span><span class='hs-varid'>ls</span><span class='hs-layout'>)</span> <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>listApply</span> <span class='hs-varid'>ls</span> <span class='hs-varop'>$</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>l</span>
</pre><p>But surely this can’t possibly typecheck: <code>add5</code> has type</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>add5</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Num</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
</pre><p>but as soon as we apply one argument to it, the type becomes</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>add4</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Num</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
</pre><p>We have a couple of options: we can do this rather easily with Template Haskell, or we can have a little more fun and create a recursive type in order to make <code>listApply</code> typecheck.</p><h2 id="template-haskell">Template Haskell</h2><p>(Note: this file is Literate Haskell. You can grab the <a
href="http://github.jfet.org/lhs/ListApply.lhs">raw version</a>, dump it into GHCI, and play along at home. Don’t forget the <code>-XTemplateHaskell</code> argument.)</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-comment'>{-# LANGUAGE TemplateHaskell #-}</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>ListApply</span> <span class='hs-keyword'>where</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Language</span><span class='hs-varop'>.</span><span class='hs-conid'>Haskell</span><span class='hs-varop'>.</span><span class='hs-conid'>TH</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Language</span><span class='hs-varop'>.</span><span class='hs-conid'>Haskell</span><span class='hs-varop'>.</span><span class='hs-conid'>TH</span><span class='hs-varop'>.</span><span class='hs-conid'>Syntax</span>
</pre><p>First, if we want to play with functions that take arguments of type <code>Double</code>, we’ll need an instance for the Lift typeclass:</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Lift</span> <span class='hs-conid'>Double</span> <span class='hs-keyword'>where</span>
<span class='hs-varop'>&gt;</span>     <span class='hs-varid'>lift</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>LitE</span> <span class='hs-layout'>(</span><span class='hs-conid'>RationalL</span> <span class='hs-layout'>(</span><span class='hs-varid'>toRational</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
</pre><p>Now then, we can just splice up a syntax tree corresponding to what we really wanted to do above with <code>listApply</code>:</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>lApplyTH'</span>    <span class='hs-conid'>[]</span>  <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>VarE</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkName</span> <span class='hs-varid'>fn</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>lApplyTH'</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-conop'>:</span><span class='hs-varid'>ls</span><span class='hs-layout'>)</span> <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>|</span> <span class='hs-varop'>$</span><span class='hs-layout'>(</span><span class='hs-varid'>lApplyTH'</span> <span class='hs-varid'>ls</span> <span class='hs-varid'>fn</span><span class='hs-layout'>)</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>|</span><span class='hs-keyglyph'>]</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>lApplyTH</span> <span class='hs-varid'>ls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lApplyTH'</span> <span class='hs-varop'>$</span> <span class='hs-varid'>reverse</span> <span class='hs-varid'>ls</span>
</pre><p>Then we can splice in a list call somewhere in our code:</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-varop'>$</span><span class='hs-layout'>(</span><span class='hs-varid'>lApplyTH</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-num'>2</span><span class='hs-layout'>,</span><span class='hs-num'>3</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>::</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Double</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-str'>"**"</span><span class='hs-layout'>)</span>
</pre><p>Of course, this is annoying in a few ways: the stage restriction prevents us from using this code in the same module as the definition of <code>lApplyTH</code>, and we have to use the name of the function rather than the function itself when constructing the AST.</p><h2 id="isorecursive-datatype">Isorecursive Datatype</h2><p>We can also accomplish our goal (in a slightly more interesting way, no less) using an isorecursive datatype while avoiding Template Haskell entirely.</p><p>Returning to the original <code>listApply</code> definition above, what if we made a datatype that would encapsulate the fact that we’re applying an argument such that upon applying an argument, we get back a value of the same type?</p><p>The base case is easy:</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>RecT</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RecR</span> <span class='hs-varid'>a</span>
</pre><p>We roll up a bare value inside the base case constructor <code>RecR</code>, and upon unrolling it we get something out of type <code>a</code>. What about the recursive call?</p><pre><span class='hs-varop'>&gt;</span>             <span class='hs-keyglyph'>|</span> <span class='hs-conid'>RecCR</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RecT</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
</pre><p>Here, we roll up an application of type <code>a</code> to a <code>RecT</code>, generating another <code>RecT</code>.</p><p>Note that the structure of this datatype is extremely similar to the structure of the list datatype. In effect, we’re morphing our function into a list-like object.</p><p>To actually create a <code>RecT</code>, we might say</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>rolled1Value</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RecR</span> <span class='hs-layout'>(</span><span class='hs-num'>1</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Integer</span><span class='hs-layout'>)</span>
</pre><p>This is an integer wrapped up into a <code>RecT Integer</code>. More generally:</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>lift0RecT</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RecR</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>rolled1Value</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lift0RecT</span> <span class='hs-num'>1</span>
</pre><p>Let’s go one step further: what if we want to roll up a function of one argument?</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>lift1RecT</span> <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RecCR</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lift0RecT</span> <span class='hs-varop'>$</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>a</span>
</pre><p>This is slightly tricky. If we already had the argument for our function, we could make a <code>RecT</code> by lifting the result of the function application to the argument with <code>RecR</code>. Thus, we assume that we have the argument by wrapping the lift inside a lambda, then make a <code>RecT</code> by wrapping the lambda inside a <code>RecCR</code>.</p><p>We can do this for a function of two arguments by extending our lifting function in the same way, and so on and so forth:</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>lift2RecT</span> <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RecCR</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lift1RecT</span> <span class='hs-varop'>$</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>a</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>lift3RecT</span> <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RecCR</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lift2RecT</span> <span class='hs-varop'>$</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>a</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>lift4RecT</span> <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RecCR</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lift3RecT</span> <span class='hs-varop'>$</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>a</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>lift5RecT</span> <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RecCR</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lift4RecT</span> <span class='hs-varop'>$</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>a</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>lift6RecT</span> <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RecCR</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lift5RecT</span> <span class='hs-varop'>$</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>a</span>
</pre><p>OK, we can roll stuff up, but how the heck do we unroll it? Pattern matching, naturally:</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>unrollRecT</span> <span class='hs-layout'>(</span><span class='hs-conid'>RecR</span> <span class='hs-varid'>val</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>val</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>unrollRecT</span> <span class='hs-keyword'>_</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>reduceRecT</span> <span class='hs-layout'>(</span><span class='hs-conid'>RecCR</span> <span class='hs-varid'>fn</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fn</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>reduceRecT</span> <span class='hs-keyword'>_</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
</pre><p>You might ask what the hell we’re doing with two separate functions here. The answer is that we’re avoiding the occurs check! We haven’t completely hidden our crazy ways inside <code>RecT</code>, and we still need to be up-front with the type system about whether we expect a value (<code>RecR</code>) or a function application (<code>RecCR</code>). Put another way: <code>val</code> and <code>fn</code> don’t have the same type, so <code>unrollRecT</code> and <code>reduceRecT</code> can’t be collapsed into one function.</p><p>To apply a list, we just have to go on an unrolling spree:</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>lApply</span>    <span class='hs-conid'>[]</span>  <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unrollRecT</span> <span class='hs-varid'>fn</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>lApply</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-conop'>:</span><span class='hs-varid'>ls</span><span class='hs-layout'>)</span> <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lApply</span> <span class='hs-varid'>ls</span> <span class='hs-varop'>$</span> <span class='hs-layout'>(</span><span class='hs-varid'>reduceRecT</span> <span class='hs-varid'>fn</span><span class='hs-layout'>)</span> <span class='hs-varid'>l</span>
</pre><p>(Note that we don’t have to reverse the list order this time, since we reversed it once when rolling up the function and then again when unrolling it.)</p><p>Now then, if we define</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>powRecT</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lift2RecT</span> <span class='hs-layout'>(</span><span class='hs-varop'>**</span><span class='hs-layout'>)</span>
</pre><p>then we could say</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>lApply</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>2</span><span class='hs-layout'>,</span><span class='hs-num'>3</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>powRecT</span>
</pre><p>Sadly, the way we’ve defined <code>lApply</code> precludes partial application. However, we could allow partial applications by leaving off the final unroll:</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>lApplyPart</span>    <span class='hs-conid'>[]</span>  <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fn</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>lApplyPart</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-conop'>:</span><span class='hs-varid'>ls</span><span class='hs-layout'>)</span> <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lApplyPart</span> <span class='hs-varid'>ls</span> <span class='hs-varop'>$</span> <span class='hs-layout'>(</span><span class='hs-varid'>reduceRecT</span> <span class='hs-varid'>fn</span><span class='hs-layout'>)</span> <span class='hs-varid'>l</span>
</pre><p>In that case, we’d have to manually unroll it ourselves, or just use <code>lApply</code> on the final application:</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>lApply</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>3</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>$</span> <span class='hs-varid'>lApplyPart</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>2</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>powRecT</span>
</pre><p>The other thing that might be useful is actually making a function that takes a list directly, rather than one that has to be evaluated with <code>lApply</code>. Trivially,</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>listPow</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flip</span> <span class='hs-varid'>lApply</span> <span class='hs-varid'>powRecT</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>listPowPart</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flip</span> <span class='hs-varid'>lApplyPart</span> <span class='hs-varid'>powRecT</span>
</pre><p>For the second one, we always have to remember to unroll it ourselves once we’ve applied enough values:</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>lApply</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>3</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-varid'>listPowPart</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>2</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
</pre><h2 id="conclusions">Conclusions</h2><p>Compared to something like scheme where no one would bat an eyelash at recursively applying values from a list to a curried function, the Haskell type system clearly demands a bit more formality. As I noted above, this example is pretty limited in its usefulness; nevertheless, it’s an interesting little thought experiment, and of course isorecursive datatypes are hugely useful (lists, anyone?).</p><p>If you haven’t yet, you might read through a discussion on expressing the <a href="http://blog.jfet.org/2009/06/14#2009061401">Y-combinator in a Hindley-Milner type system</a>. You’ll likely find the material very familiar once you’ve read the above.</p>
<p><a href="./" style="text-decoration:none;float:left;">&larr;</a></p>
<p class="footnote">Questions? Comments?<br />
<a href="http://twitter.com/kwantam">@kwantam</a> | &lt;<a href="mailto:kwantam@gmail.com">kwantam@gmail.com</a>&gt; | <a href="http://github.com/kwantam">github</a></p>
</body>
</html>
