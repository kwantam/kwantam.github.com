<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Riad Wahby" />
  <title>Efficiently Detecting Illegal States in Twisted-Ring FSM State Vectors</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="css/hscolour.css" type="text/css" />
  <link rel="stylesheet" href="css/main.css" type="text/css" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Brawler|Lato|Inconsolata" type="text/css" />
  <link rel="SHORTCUT ICON" href="images/favicon.png">
</head>
<body>
<div id="header">
<h1 class="title">Efficiently Detecting Illegal States in Twisted-Ring FSM State Vectors</h1>
<h2 class="author">Riad Wahby</h2>
<h3 class="date">2013 Mar 10</h3>
</div>
<p>Let’s meditate for a moment on the nature of FSMs utilizing twisted-ring state vectors. Such FSMs have some nice properties: a more efficient state coding than a one-hot machine, gray state transitions, and a trivial computation of the next state vector.</p><p>However, since not all state bit vectors represent legal states, most designers will want to include illegal state detection. While not as onerous as illegal state detection in a one-hot machine, at first blush it seems that illegal state detection could be far worse than in a FSM using compact state coding.</p><p>Let’s see if we can’t do a little better. First, some setup.</p><p>(Note: this file is Literate Haskell. You can grab the <a href="http://kwantam.github.com/lhs/IllegalStates.lhs">raw version</a>, dump it into GHCI, and play along at home!)</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>IllegalStates</span> <span class='hs-keyword'>where</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>List</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>\\</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>findIndices</span><span class='hs-layout'>,</span> <span class='hs-varid'>nubBy</span><span class='hs-layout'>)</span>
</pre><p>We’re talking about logic, but <code>Bool</code>s are visually noisy. Let’s just agree to behave ourselves and operate on lists containing 0 and 1 to make for less typing and easier reading.</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>inv</span> <span class='hs-num'>1</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>inv</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>inv</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
</pre><h2 id="generating-twisted-rings">Generating Twisted Rings</h2><p>The twisted ring transition is simple: shift all the bits left, and insert the inverse of the MSB into the LSB. (See also: <a href="http://en.wikipedia.org/wiki/Ring_counter">Ring counter</a> (Wikipedia))</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>tRingNext</span>    <span class='hs-conid'>[]</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>tRingNext</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bs</span> <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>inv</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
</pre><p><code>iterate</code> takes a function and an initial argument and creates an infinite list of applications of the function to the previous value of the list, with the initial argument itself as the base case. Using this, we can make a function that returns a (possibly) finite list by ending when we see the initial argument again.</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>iterateUniq</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>takeWhile</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>y</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span> <span class='hs-varop'>/=</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>
<span class='hs-varop'>&gt;</span>     <span class='hs-keyword'>where</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>iterate</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span>
</pre><p>Applying this operation to the twisted ring transition gives us a function that returns a list of all states of a twisted ring counter starting at some initial state.</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>tRing</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>iterateUniq</span> <span class='hs-varid'>tRingNext</span>
</pre><p>We’re treating lists of <code>{0,1}</code> as bit vectors; we’ll want a way to generate all possible bit vectors of a given length:</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>bitStrings</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>[]</span><span class='hs-keyglyph'>]</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>bitStrings</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-num'>0</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varid'>nm1</span> <span class='hs-layout'>)</span> <span class='hs-varop'>++</span> <span class='hs-layout'>(</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-num'>1</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varid'>nm1</span> <span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>where</span> <span class='hs-varid'>nm1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bitStrings</span> <span class='hs-varop'>$</span> <span class='hs-varid'>n</span> <span class='hs-comment'>-</span> <span class='hs-num'>1</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>allStates5</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bitStrings</span> <span class='hs-num'>5</span>
</pre><h2 id="legal-states">Legal States</h2><p>Legal states in a twisted ring FSM are those in the ring containing the state with all zeros. For example, in a 5-bit ring:</p><pre><code>00000
00001
00011
00111
01111
11111
11110
11100
11000
10000</code></pre><p>Note that these rings have an interesting property: in any state, there is at most one sequential pair of dissimilar bits. Further, we can uniquely identify all ten states by looking at only two bits. In the case of the states that are all 0 or all 1, we look at the first and last bits, because we know that if they’re the same all the ones between must be as well. In the other states, we look for the 01 or 10 transition, whose position is unique among the states.</p><p>Thus, we could write a set of ten functions each of which selects one of the legal states. These might look like</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>inState0</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-num'>0</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-layout'>;</span> <span class='hs-varid'>inState0</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>inState1</span> <span class='hs-keyglyph'>[</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-num'>0</span><span class='hs-layout'>,</span><span class='hs-num'>1</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-layout'>;</span> <span class='hs-varid'>inState1</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>inState2</span> <span class='hs-keyglyph'>[</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-num'>0</span><span class='hs-layout'>,</span><span class='hs-num'>1</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-layout'>;</span> <span class='hs-varid'>inState2</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>inState3</span> <span class='hs-keyglyph'>[</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-num'>0</span><span class='hs-layout'>,</span><span class='hs-num'>1</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-layout'>;</span> <span class='hs-varid'>inState3</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>inState4</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-layout'>,</span><span class='hs-num'>1</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-layout'>;</span> <span class='hs-varid'>inState4</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>inState5</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>1</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-num'>1</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-layout'>;</span> <span class='hs-varid'>inState5</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>inState6</span> <span class='hs-keyglyph'>[</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-num'>1</span><span class='hs-layout'>,</span><span class='hs-num'>0</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-layout'>;</span> <span class='hs-varid'>inState6</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>inState7</span> <span class='hs-keyglyph'>[</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-num'>1</span><span class='hs-layout'>,</span><span class='hs-num'>0</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-layout'>;</span> <span class='hs-varid'>inState7</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>inState8</span> <span class='hs-keyglyph'>[</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-num'>1</span><span class='hs-layout'>,</span><span class='hs-num'>0</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-layout'>;</span> <span class='hs-varid'>inState8</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>inState9</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>1</span><span class='hs-layout'>,</span><span class='hs-num'>0</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-layout'>;</span> <span class='hs-varid'>inState9</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
</pre><p>But why write functions we can generate instead?</p><h2 id="generating-one-hot-selectors-for-legal-states">Generating One-Hot Selectors For Legal States</h2><p>Let’s consider how we can generate the one-hot bit selectors for the legal states. Recall from above that these have a specific form: either every bit in the vector is the same, in which case the first and last bit in the vector are the same, or the beginning and end of the vector have opposite polarity, and there is one 01 or 10 transition somewhere in the vector.</p><p>Obviously there’s nothing to detect in vectors of 0 length:</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>oneHotVecs</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
</pre><p>Otherwise, we can easily make the selectors for all-0 or all-1 vectors and generate a list of selectors for 01 and 10.</p><p><code>allX</code> simply matches the first and last elements of a list to some supplied value, in our case 0 or 1. <code>selX</code> generates a list of functions that match a supplied list against some subsequence of length two of the argument.</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>oneHotVecs</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>allX</span> <span class='hs-num'>0</span> <span class='hs-conop'>:</span> <span class='hs-varid'>selX</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-layout'>,</span><span class='hs-num'>1</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-num'>2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>++</span> <span class='hs-layout'>(</span><span class='hs-varid'>allX</span> <span class='hs-num'>1</span> <span class='hs-conop'>:</span> <span class='hs-varid'>selX</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>1</span><span class='hs-layout'>,</span><span class='hs-num'>0</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-num'>2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>where</span> <span class='hs-varid'>allX</span> <span class='hs-varid'>x</span> <span class='hs-varid'>ls</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>head</span> <span class='hs-varid'>ls</span> <span class='hs-varop'>==</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>last</span> <span class='hs-varid'>ls</span> <span class='hs-varop'>==</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>selX</span> <span class='hs-varid'>x</span> <span class='hs-varid'>m</span> 
<span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>m</span> <span class='hs-varop'>&lt;</span> <span class='hs-num'>0</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>ls</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>take</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>drop</span> <span class='hs-varid'>m</span> <span class='hs-varid'>ls</span><span class='hs-layout'>)</span> <span class='hs-varop'>==</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>                         <span class='hs-conop'>:</span> <span class='hs-varid'>selX</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-varid'>m</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>inStatesL5</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>oneHotVecs</span> <span class='hs-num'>5</span>
</pre><p><code>inStatesL5</code> is now just the list of <code>inStateX</code> functions given above.</p><p>If we want to apply multiple selectors simultaneously, we might provide a list of them and apply them all to a given input. Here’s one way to do this in an abrasively point-free style:</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>allL</span> <span class='hs-varid'>fns</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>and</span> <span class='hs-varop'>.</span> <span class='hs-varid'>flip</span> <span class='hs-varid'>map</span> <span class='hs-varid'>fns</span> <span class='hs-varop'>.</span> <span class='hs-varid'>flip</span> <span class='hs-layout'>(</span><span class='hs-varop'>$</span><span class='hs-layout'>)</span>
</pre><p>If we were feeling somewhat less obtuse, we might instead say</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>allL</span> <span class='hs-varid'>fns</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>and</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varop'>$</span><span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varid'>fns</span><span class='hs-layout'>)</span>
</pre><h2 id="illegal-states">Illegal States</h2><p>The illegal states are all bit strings of length N that aren’t in the ring consisting of N zeros.</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>illegalStates5</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>allStates5</span> <span class='hs-varop'>\\</span> <span class='hs-varid'>tRing</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-layout'>,</span><span class='hs-num'>0</span><span class='hs-layout'>,</span><span class='hs-num'>0</span><span class='hs-layout'>,</span><span class='hs-num'>0</span><span class='hs-layout'>,</span><span class='hs-num'>0</span><span class='hs-keyglyph'>]</span>
</pre><p>Like the legal states, the illegal states form closed rings: if one state is in another state’s ring, then we can be sure that the two states produce identical rings modulo a phase shift. This lets us easily uniqify the list of illegal states into a seed list containing one (arbitrarily chosen) representative member of each illegal ring.</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>sameRing</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span> <span class='hs-varop'>/=</span> <span class='hs-varid'>findIndices</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>tRing</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>illegalState5Seeds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nubBy</span> <span class='hs-varid'>sameRing</span> <span class='hs-varid'>illegalStates5</span>
</pre><p>Now we can also segregate all the illegal states into their respective rings:</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>illegalState5Rings</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>tRing</span> <span class='hs-varid'>illegalState5Seeds</span>
</pre><p>One obvious question to ask: how many of the legal state selectors will an illegal state trigger? Let’s apply all the selectors to all the states to find out.</p><p>At this point I think it’s clear we have no choice but to escalate our abuse of <code>flip</code> et al:</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>nTrigStateSels</span> <span class='hs-varid'>selL</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varop'>$</span> <span class='hs-varid'>flip</span> <span class='hs-varid'>map</span> <span class='hs-varid'>selL</span> <span class='hs-varop'>.</span> <span class='hs-varid'>flip</span> <span class='hs-layout'>(</span><span class='hs-varop'>$</span><span class='hs-layout'>)</span>
</pre><p>OK, I admit the golfing is getting a little absurd. We could also just say</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>nTrigStateSels</span> <span class='hs-varid'>selL</span> <span class='hs-varid'>states</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varop'>$</span><span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varid'>selL</span><span class='hs-layout'>)</span> <span class='hs-varid'>states</span>
</pre><p>Now then, the results of such an application:</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>inStateVecs5</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nTrigStateSels</span> <span class='hs-varid'>inStatesL5</span> <span class='hs-varid'>allStates5</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>numInStatesByString</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zip</span> <span class='hs-varid'>allStates5</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varop'>.</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span> <span class='hs-varid'>inStateVecs5</span>
</pre><p>Looking at this list we see that legal states match exactly 1 selector (as we should expect), while most illegal states match 3 selectors. The two alternating states, 01010 and 10101, each match 5 selectors!</p><h2 id="canary-combinations">Canary Combinations</h2><p>Now, the million dollar question: can we pick some subset of the selectors such that those selectors will all match at least one state in all of the illegal rings? If we can, then we’ve found a much less expensive way of detecting illegal states (though note that we will likely have to transition through a few illegal states before we get to one that we detect as such).</p><p>Obviously, we’ll need to be able to generate n-way combinations so that we can make a bunch of multi-selectors:</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>combinations</span> <span class='hs-num'>0</span>    <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>combinations</span> <span class='hs-num'>1</span>    <span class='hs-varid'>ls</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-varid'>ls</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>combinations</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-conop'>:</span><span class='hs-varid'>ls</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cHlp</span> <span class='hs-varid'>l</span> <span class='hs-varid'>ls</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>where</span> <span class='hs-varid'>cHlp</span> <span class='hs-varid'>l</span> <span class='hs-conid'>[]</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>cHlp</span> <span class='hs-varid'>l</span> <span class='hs-varid'>l2</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>nl</span><span class='hs-conop'>:</span><span class='hs-varid'>nl2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>combinations</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>l2</span><span class='hs-layout'>)</span> <span class='hs-varop'>++</span> <span class='hs-varid'>cHlp</span> <span class='hs-varid'>nl</span> <span class='hs-varid'>nl2</span>
</pre><p>Now we can generate all two-way selector functions. Sadly, there’s no good way of making a <code>Show</code> instance for functions; instead, we’re going to make a new “named function” datatype that’s showable. (Note, though, that our <code>Eq</code>, <code>Ord</code>, and <code>Show</code> instances only work on the names, not on the functions themselves.)</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>NamedFunc</span> <span class='hs-varid'>n</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NFunc</span> <span class='hs-varid'>n</span> <span class='hs-varid'>f</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>applyNF</span> <span class='hs-layout'>(</span><span class='hs-conid'>NFunc</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>nameNF</span> <span class='hs-layout'>(</span><span class='hs-conid'>NFunc</span> <span class='hs-varid'>n</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Show</span> <span class='hs-varid'>t1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Show</span> <span class='hs-layout'>(</span><span class='hs-conid'>NamedFunc</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>show</span> <span class='hs-varid'>nf</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>"NF"</span> <span class='hs-varop'>++</span> <span class='hs-varid'>show</span> <span class='hs-layout'>(</span><span class='hs-varid'>nameNF</span> <span class='hs-varid'>nf</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>t1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>NamedFunc</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span> <span class='hs-varid'>nf1</span> <span class='hs-varid'>nf2</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>nameNF</span> <span class='hs-varid'>nf1</span><span class='hs-layout'>)</span> <span class='hs-varop'>==</span> <span class='hs-layout'>(</span><span class='hs-varid'>nameNF</span> <span class='hs-varid'>nf2</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>t1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Ord</span> <span class='hs-layout'>(</span><span class='hs-conid'>NamedFunc</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>compare</span> <span class='hs-varid'>nf1</span> <span class='hs-varid'>nf2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-varid'>nameNF</span> <span class='hs-varid'>nf1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>nameNF</span> <span class='hs-varid'>nf2</span><span class='hs-layout'>)</span>
</pre><p>Using this,</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>twoStateCombFuncs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>allL</span> <span class='hs-varop'>$</span> <span class='hs-varid'>combinations</span> <span class='hs-num'>2</span> <span class='hs-varid'>inStatesL5</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>twoStateCombNames</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>combinations</span> <span class='hs-num'>2</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-layout'>,</span><span class='hs-num'>1</span><span class='hs-layout'>,</span><span class='hs-num'>2</span><span class='hs-layout'>,</span><span class='hs-num'>3</span><span class='hs-layout'>,</span><span class='hs-num'>4</span><span class='hs-layout'>,</span><span class='hs-num'>5</span><span class='hs-layout'>,</span><span class='hs-num'>6</span><span class='hs-layout'>,</span><span class='hs-num'>7</span><span class='hs-layout'>,</span><span class='hs-num'>8</span><span class='hs-layout'>,</span><span class='hs-num'>9</span><span class='hs-keyglyph'>]</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>twoStateCombs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWith</span> <span class='hs-conid'>NFunc</span> <span class='hs-varid'>twoStateCombNames</span> <span class='hs-varid'>twoStateCombFuncs</span>
</pre><p>Now <code>twoStateCombs</code> is a vector of <code>NamedFunc</code> that we can apply to every state in the illegal rings. We are looking for a <code>NamedFunc</code> that matches at least one state in all illegal rings.</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>canaryCombos5</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>isTrue</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-varid'>tryComb</span> <span class='hs-varid'>twoStateCombs</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>where</span> <span class='hs-varid'>tryComb</span> <span class='hs-varid'>nf</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>nf</span><span class='hs-layout'>,</span><span class='hs-varid'>and</span> <span class='hs-varop'>$</span> <span class='hs-varid'>flip</span> <span class='hs-varid'>map</span> <span class='hs-varid'>illegalState5Rings</span>
<span class='hs-varop'>&gt;</span>                              <span class='hs-varop'>$</span> <span class='hs-varid'>or</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>applyNF</span> <span class='hs-varid'>nf</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>isTrue</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span>
</pre><p>For each canary combination, we might be interested in knowing how many total states they match; a canary that matches more states will, on average, detect that we’re in an illegal state more quickly.</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>canaryMatches5</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>nMatches</span> <span class='hs-varid'>canaryCombos5</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>where</span> <span class='hs-varid'>nMatches</span> <span class='hs-layout'>(</span><span class='hs-varid'>nf</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>nf</span><span class='hs-layout'>,</span> <span class='hs-varid'>length</span> <span class='hs-varop'>.</span> <span class='hs-varid'>concat</span> <span class='hs-varop'>$</span> 
<span class='hs-varop'>&gt;</span>                                <span class='hs-layout'>(</span> <span class='hs-varid'>map</span> <span class='hs-varop'>.</span> <span class='hs-varid'>filter</span> <span class='hs-varop'>$</span> <span class='hs-varid'>applyNF</span> <span class='hs-varid'>nf</span> <span class='hs-layout'>)</span> <span class='hs-varid'>illegalState5Rings</span><span class='hs-layout'>)</span>
</pre><p>Sadly, at least in the case of 5-bit rings, all of them match exactly 4 states.</p><p>Now that we’ve worked through the whole process by hand for 5-bit rings, let’s put it all together into a function that dumps out all the canary combinations for a ring of some specified length.</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>canaryCombos</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>isTrue</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-varid'>tryComb</span> <span class='hs-varid'>twoSelNFs</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>where</span> <span class='hs-varid'>isTrue</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>tryComb</span> <span class='hs-varid'>nf</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>nf</span><span class='hs-layout'>,</span><span class='hs-varid'>and</span> <span class='hs-varop'>$</span> <span class='hs-varid'>flip</span> <span class='hs-varid'>map</span> <span class='hs-varid'>illRings</span> <span class='hs-varop'>$</span> <span class='hs-varid'>or</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>applyNF</span> <span class='hs-varid'>nf</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>illStates</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>bitStrings</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varop'>\\</span> <span class='hs-layout'>(</span><span class='hs-varid'>tRing</span> <span class='hs-varop'>.</span> <span class='hs-varid'>take</span> <span class='hs-varid'>n</span> <span class='hs-varop'>$</span> <span class='hs-varid'>repeat</span> <span class='hs-num'>0</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>illSeeds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nubBy</span> <span class='hs-varid'>sameRing</span> <span class='hs-varid'>illStates</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>illRings</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>tRing</span> <span class='hs-varid'>illSeeds</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>twoSelFns</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>allL</span> <span class='hs-varop'>$</span> <span class='hs-varid'>combinations</span> <span class='hs-num'>2</span> <span class='hs-varop'>$</span> <span class='hs-varid'>oneHotVecs</span> <span class='hs-varid'>n</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>twoSelNms</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>combinations</span> <span class='hs-num'>2</span> <span class='hs-varop'>$</span> <span class='hs-varid'>take</span> <span class='hs-layout'>(</span><span class='hs-num'>2</span><span class='hs-varop'>*</span><span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>twoSelNFs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWith</span> <span class='hs-conid'>NFunc</span> <span class='hs-varid'>twoSelNms</span> <span class='hs-varid'>twoSelFns</span>
</pre><p>Very interesting! Sadly, 5-bit rings seem to be the maximum for which a single two-selector canary is possible. That means we’ll have to look for combinations of two or more canaries such that at least one canary flags at least one state in each ring.</p><p>To do this, we apply the pairwise canaries to all members of each ring, as above. Next, we make m-way combinations of the results, ORing the results of the canaries’ application to the rings and looking for a full set of matches.</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>anyL</span> <span class='hs-varid'>fns</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>or</span> <span class='hs-varop'>.</span> <span class='hs-varid'>flip</span> <span class='hs-varid'>map</span> <span class='hs-varid'>fns</span> <span class='hs-varop'>.</span> <span class='hs-varid'>flip</span> <span class='hs-layout'>(</span><span class='hs-varop'>$</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>canaryOrCombos</span> <span class='hs-varid'>n</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>isTrue</span> <span class='hs-varid'>mCombs</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>where</span> <span class='hs-varid'>illStates</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bitStrings</span> <span class='hs-varid'>n</span> <span class='hs-varop'>\\</span> <span class='hs-layout'>(</span><span class='hs-varid'>tRing</span> <span class='hs-varop'>.</span> <span class='hs-varid'>take</span> <span class='hs-varid'>n</span> <span class='hs-varop'>$</span> <span class='hs-varid'>repeat</span> <span class='hs-num'>0</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>illSeeds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nubBy</span> <span class='hs-varid'>sameRing</span> <span class='hs-varid'>illStates</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>illRings</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>tRing</span> <span class='hs-varid'>illSeeds</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>twoSelFns</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>allL</span> <span class='hs-varop'>$</span> <span class='hs-varid'>combinations</span> <span class='hs-num'>2</span> <span class='hs-varop'>$</span> <span class='hs-varid'>oneHotVecs</span> <span class='hs-varid'>n</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>twoSelNms</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>combinations</span> <span class='hs-num'>2</span> <span class='hs-varop'>$</span> <span class='hs-varid'>take</span> <span class='hs-layout'>(</span><span class='hs-num'>2</span><span class='hs-varop'>*</span><span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>twoSelNFs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWith</span> <span class='hs-conid'>NFunc</span> <span class='hs-varid'>twoSelNms</span> <span class='hs-varid'>twoSelFns</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>applyNFs</span> <span class='hs-varid'>nf</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>nf</span><span class='hs-layout'>,</span><span class='hs-varid'>flip</span> <span class='hs-varid'>map</span> <span class='hs-varid'>illRings</span> <span class='hs-varop'>$</span> <span class='hs-varid'>or</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>applyNF</span> <span class='hs-varid'>nf</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>twoSelOut</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>applyNFs</span> <span class='hs-varid'>twoSelNFs</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>twoSelMCombs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>combinations</span> <span class='hs-varid'>m</span> <span class='hs-varid'>twoSelOut</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>mCombN</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varop'>$</span> <span class='hs-varid'>nameNF</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fst</span><span class='hs-layout'>)</span> <span class='hs-varid'>twoSelMCombs</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>mCombF</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>anyL</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>applyNF</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fst</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>twoSelMCombs</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>mCombR</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>and</span> <span class='hs-varop'>.</span> <span class='hs-varid'>foldl1</span> <span class='hs-layout'>(</span><span class='hs-varid'>zipWith</span> <span class='hs-layout'>(</span><span class='hs-varop'>||</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-varid'>snd</span><span class='hs-layout'>)</span> <span class='hs-varid'>twoSelMCombs</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>mCombs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWith3</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>n</span> <span class='hs-varid'>f</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>NFunc</span> <span class='hs-varid'>n</span> <span class='hs-varid'>f</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>mCombN</span> <span class='hs-varid'>mCombF</span> <span class='hs-varid'>mCombR</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>isTrue</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span>
</pre><p>Note that we could now just redefine</p><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>canaryCombos</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flip</span> <span class='hs-varid'>canaryOrCombos</span> <span class='hs-num'>1</span>
</pre><p>Fascinating. 2, 3, 4, and 5-bit rings need a single selector pair; 6, 7, and 8-bit rings need two selector pairs; 9, 10, and 11-bit rings need 3; and 12-bit rings seem to require 4. The pattern appears to be that an N-bit ring needs <code>floor(N/3)</code> selectors to form a canary combination.</p><p>With a little work, perhaps we could derive this result rigorously. For now, I think that’s sufficient meditation.</p>
<p><a href="./" style="text-decoration:none;float:left;">&larr;</a></p>
<p class="footnote">Questions? Comments?<br />
<a href="https://twitter.com/kwantam">@kwantam</a> | &lt;<a href="mailto:kwantam@gmail.com">kwantam@gmail.com</a>&gt; | <a href="https://github.com/kwantam">github</a></p>
</body>
</html>
